# Copyright (C) 2023 CharlesWithC All rights reserved.
# Author: @CharlesWithC

import json
import math
import os
import time
from datetime import datetime
from typing import Optional

from fastapi import Header, Request, Response
from fastapi.responses import RedirectResponse, StreamingResponse

import multilang as ml
from functions import *


async def get_roles(request: Request):
    app = request.app
    return app.config.roles

async def get_ranks(request: Request):
    app = request.app
    return app.config.ranks

async def get_perms(request: Request):
    app = request.app
    return app.config.perms

async def get_list(request: Request, response: Response, authorization: str = Header(None), \
        page: Optional[int] = 1, page_size: Optional[int] = 10, \
        after_userid: Optional[int] = None, \
        query: Optional[str] = '', roles: Optional[str] = '', last_seen_after: Optional[int] = None, \
        order_by: Optional[str] = "highest_role", order: Optional[str] = "desc"):
    """Returns a list of members"""
    app = request.app
    dhrid = request.state.dhrid
    await app.db.new_conn(dhrid)

    rl = await ratelimit(request, 'GET /member/list', 60, 60)
    if rl[0]:
        return rl[1]
    for k in rl[1].keys():
        response.headers[k] = rl[1][k]
    
    if app.config.privacy:
        au = await auth(authorization, request, allow_application_token = True)
        if au["error"]:
            response.status_code = au["code"]
            del au["code"]
            return au
        await ActivityUpdate(request, au["uid"], "members")

    if page_size <= 1:
        page_size = 1
    elif page_size >= 250:
        page_size = 250

    limit_roles = str2list(roles)
    if len(limit_roles) > 100:
        limit_roles = limit_roles[:100]

    query = convertQuotation(query).lower()
    
    order_by_last_seen = False
    if order_by not in ['user_id', 'name', 'uid', 'discordid', 'highest_role', 'join_timestamp', 'last_seen']:
        order_by = "user_id"
        order = "asc"
    if order_by == "last_seen":
        order_by_last_seen = True
    cvt = {"user_id": "userid", "name": "name", "uid": "uid", "discordid": "discordid", "join_timestamp": "join_timestamp", "highest_role": "highest_role", "last_seen": "userid"}
    order_by = cvt[order_by]

    sort_by_highest_role = False
    hrole_order_by = "asc"
    if order_by == "highest_role":
        sort_by_highest_role = True
        order_by = "userid"

    if order not in ['asc', 'desc']:
        order = "asc"

    if sort_by_highest_role:
        hrole_order_by = order
        if order == "ASC":
            order = "DESC"
        elif order == "DESC":
            order = "ASC"

    activity_limit = ""
    if last_seen_after is not None:
        activity_limit = f"AND user.uid IN (SELECT user_activity.uid FROM user_activity WHERE user_activity.timestamp >= {last_seen_after}) "

    hrole = {}
    if order_by_last_seen:
        await app.db.execute(dhrid, f"SELECT user.userid, user.roles FROM user LEFT JOIN user_activity ON user.uid = user_activity.uid WHERE LOWER(user.name) LIKE '%{query}%' AND user.userid >= 0 {activity_limit} ORDER BY user_activity.timestamp {order}, user.userid ASC")
    else:
        await app.db.execute(dhrid, f"SELECT user.userid, user.roles FROM user LEFT JOIN user_activity ON user.uid = user_activity.uid WHERE LOWER(user.name) LIKE '%{query}%' AND user.userid >= 0 {activity_limit} ORDER BY {order_by} {order}, user.userid ASC")
    t = await app.db.fetchall(dhrid)
    rret = {}
    for tt in t:
        if tt[0] in hrole.keys(): # prevent duplicate result from SQL query
            continue
        roles = str2list(tt[1])
        highest_role = 99999
        ok = False
        if len(limit_roles) == 0:
            ok = True
        for role in roles:
            if role < highest_role:
                highest_role = role
            if role in limit_roles:
                ok = True
        if not ok:
            continue
        hrole[tt[0]] = highest_role
        rret[tt[0]] = await GetUserInfo(request, userid = tt[0])

    ret = []
    if sort_by_highest_role:
        hrole = dict(sorted(hrole.items(), key=lambda x: (x[1], x[0])))
        if hrole_order_by == "ASC":
            hrole = dict(reversed(list(hrole.items())))
    for userid in hrole.keys():
        ret.append(rret[userid])
        
    if after_userid is not None:
        while len(ret) > 0 and ret[0]["userid"] != after_userid:
            ret = ret[1:]
        
    return {"list": ret[max(page-1, 0) * page_size : page * page_size], "total_items": len(ret), "total_pages": int(math.ceil(len(ret) / page_size))}

async def get_banner(request: Request, response: Response, 
    userid: Optional[int] = None, uid: Optional[int] = None, discordid: Optional[int] = None, steamid: Optional[int] = None, truckersmpid: Optional[int] = None):
    """Returns the banner generated by [BannerGen]"""
    app = request.app
    dhrid = request.state.dhrid
    await app.db.new_conn(dhrid)

    qu = ""
    if userid is not None:
        qu = f"userid = {userid}"
    elif uid is not None:
        qu = f"uid = {uid}"
    elif discordid is not None:
        qu = f"discordid = {discordid}"
    elif steamid is not None:
        qu = f"steamid = {steamid}"
    elif truckersmpid is not None:
        qu = f"truckersmpid = {truckersmpid}"
    else:
        response.status_code = 404
        return {"error": ml.tr(request, "user_not_found")}
    
    await app.db.execute(dhrid, f"SELECT name, discordid, avatar, join_timestamp, roles, userid FROM user WHERE {qu} AND userid >= 0")
    t = await app.db.fetchall(dhrid)
    if len(t) == 0 or t[0][5] == -1:
        response.status_code = 404
        return {"error": ml.tr(request, "user_not_found")}

    if userid == -1:
        return RedirectResponse(url=f"{app.config.prefix}/member/banner?userid={t[0][5]}", status_code=302)

    for param in request.query_params:
        if param != "userid":
            return RedirectResponse(url=f"{app.config.prefix}/member/banner?userid={userid}", status_code=302)
            
    t = t[0]
    userid = t[5]
    name = t[0]
    tname = name
    while tname.startswith(" "):
        tname = tname[1:]
    name = tname
    discordid = t[1]
    avatar = t[2]
    join_timestamp = t[3]
    roles = str2list(t[4])
    highest = None
    highest_role = ""
    for role in roles:
        if highest is None or role < highest:
            highest = role
            if highest in app.roles.keys():
                highest_role = app.roles[highest]["name"]
                break
            else:
                highest = None
    joined = datetime.fromtimestamp(join_timestamp)
    joined = f"{joined.year}/{str(joined.month).zfill(2)}/{str(joined.day).zfill(2)}"

    if os.path.exists(f"/tmp/hub/banner/{app.config.abbr}_{userid}.png"):
        if time.time() - os.path.getmtime(f"/tmp/hub/banner/{app.config.abbr}_{userid}.png") <= 600:
            response = StreamingResponse(iter([open(f"/tmp/hub/banner/{app.config.abbr}_{userid}.png","rb").read()]), media_type="image/jpeg")
            return response

    rl = await ratelimit(request, 'GET /member/banner', 10, 5)
    if rl[0]:
        return rl[1]
    for k in rl[1].keys():
        response.headers[k] = rl[1][k]

    division_name = ""
    for role in roles:
        for division in app.config.divisions:
            if division["role_id"] == role:
                division_name = division["name"]
                break
    if division_name == "":
        division_name = "N/A"

    distance = 0
    await app.db.execute(dhrid, f"SELECT SUM(distance) FROM dlog WHERE userid = {userid}")
    t = await app.db.fetchall(dhrid)
    distance = nint(t[0][0])
    if app.config.distance_unit == "imperial":
        distance = int(distance * 0.621371)
        distance = f"{tseparator(distance)}mi"
    else:
        distance = f"{tseparator(distance)}km"
    
    await app.db.execute(dhrid, f"SELECT SUM(profit) FROM dlog WHERE userid = {userid} AND unit = 1")
    t = await app.db.fetchall(dhrid)
    europrofit = 0
    if len(t) > 0:
        europrofit = nint(t[0][0])
    await app.db.execute(dhrid, f"SELECT SUM(profit) FROM dlog WHERE userid = {userid} AND unit = 2")
    t = await app.db.fetchall(dhrid)
    dollarprofit = 0
    if len(t) > 0:
        dollarprofit = nint(t[0][0])
    profit = f"â‚¬{sigfig(europrofit)} + ${sigfig(dollarprofit)}"

    try:
        r = await arequests.post(app, "http://127.0.0.1:8700/banner", data=json.dumps({"company_abbr": app.config.abbr, \
            "company_name": app.config.name, "logo_url": app.config.logo_url, "hex_color": app.config.hex_color,
            "userid": userid, "joined": joined, "highest_role": highest_role, \
                "avatar": avatar, "name": name, "division": division_name, "distance": distance, "profit": profit}), headers = {"Content-Type": "application/json"}, timeout = 5)
        if r.status_code // 100 != 2:
            response.status_code = r.status_code
            return {"error": r.text}
            
        response = StreamingResponse(iter([r.content]), media_type="image/jpeg")
        for k in rl[1].keys():
            response.headers[k] = rl[1][k]
        response.headers["Cache-Control"] = "public, max-age=600, stale-if-error=86400"
        return response
        
    except:
        response.status_code = 503
        return {"error": "Service Unavailable"}